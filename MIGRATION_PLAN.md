# Plano de Migra√ß√£o para Bun ORM com Migrations Autom√°ticas

## üìã Resumo Executivo

Este documento detalha o plano para migrar o WazMeow para usar Bun ORM com migrations geradas automaticamente a partir dos models Go, eliminando migrations manuais em SQL e garantindo sincroniza√ß√£o perfeita entre c√≥digo e banco de dados.

## üîç An√°lise das Inconsist√™ncias Atuais

### 1. **Duplica√ß√£o Cr√≠tica de Entidades Session**

**Problema**: Existem duas defini√ß√µes conflitantes da entidade Session:

#### `internal/domain/entities.go` (‚ùå Problem√°tico)
```go
type Session struct {
    ID           string        `json:"id" bun:"id,pk"`           // TAGS BUN NO DOMAIN!
    Name         string        `json:"name" bun:"name,notnull"`
    Status       SessionStatus `json:"status" bun:"status,notnull"`
    Active       bool          `json:"active" bun:"active,notnull"`     // Campo extra
    Events       []string      `json:"events" bun:"events,array"`       // Array
    LastActivity *time.Time    `json:"last_activity" bun:"last_activity"` // Campo extra
    // ... outros campos
}
```

#### `internal/domain/entity/session.go` (‚úÖ Clean Architecture)
```go
type Session struct {
    ID         string       `json:"id"`                    // SEM TAGS BUN
    Name       string       `json:"name"`
    Status     SessionStatus `json:"status"`
    Phone      string       `json:"phone,omitempty"`
    Events     string       `json:"events,omitempty"`     // String
    // ... campos diferentes
}
```

**Impacto**: 
- Viola princ√≠pios de Clean Architecture
- Confus√£o entre camadas de dom√≠nio e persist√™ncia
- Convers√µes inconsistentes no SessionModel
- Bugs potenciais na aplica√ß√£o

### 2. **Inconsist√™ncias Estruturais**

| Campo | entities.go | entity/session.go | SessionModel | Migration SQL |
|-------|-------------|-------------------|--------------|---------------|
| `Active` | `bool` | ‚ùå N√£o existe | ‚ùå N√£o existe | ‚ùå N√£o existe |
| `Events` | `[]string` | `string` | `string` | `VARCHAR` |
| `LastActivity` | `*time.Time` | ‚ùå N√£o existe | ‚ùå N√£o existe | ‚ùå N√£o existe |
| `QRCode` | ‚ùå N√£o existe | ‚ùå N√£o existe | `string` | `TEXT` |
| `ProxyConfig` | ‚ùå N√£o existe | `*ProxyConfig` | Campos separados | Campos separados |

### 3. **Problemas na Arquitetura de Migrations**

**Atual (Problem√°tico)**:
- Migration manual em SQL: [`20250109000001_create_sessions.go`](internal/infra/database/migrations/20250109000001_create_sessions.go)
- Schema hardcoded sem rela√ß√£o com models
- Altera√ß√µes em models n√£o geram migrations autom√°ticas
- Risco de desincroniza√ß√£o entre c√≥digo e banco

## üéØ Arquitetura Proposta

### **Princ√≠pios da Nova Arquitetura**

1. **Single Source of Truth**: Models Bun s√£o a √∫nica fonte da verdade
2. **Migrations Autom√°ticas**: Geradas a partir das mudan√ßas nos models
3. **Versionamento Seguro**: Cada mudan√ßa gera nova migration versionada
4. **Clean Architecture**: Dom√≠nio livre de tags de persist√™ncia

### **Estrutura Proposta**

```
internal/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ entity/
‚îÇ       ‚îî‚îÄ‚îÄ session.go           # ‚úÖ Entidade clean (sem tags Bun)
‚îú‚îÄ‚îÄ infra/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ session.go           # ‚úÖ Model Bun (com todas as tags)
‚îÇ   ‚îî‚îÄ‚îÄ database/
‚îÇ       ‚îú‚îÄ‚îÄ migrations/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ auto/            # üÜï Migrations geradas automaticamente
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ manual/          # üÜï Migrations manuais espec√≠ficas
‚îÇ       ‚îî‚îÄ‚îÄ migrator/
‚îÇ           ‚îú‚îÄ‚îÄ generator.go     # üÜï Gerador de migrations
‚îÇ           ‚îú‚îÄ‚îÄ differ.go        # üÜï Detector de mudan√ßas
‚îÇ           ‚îî‚îÄ‚îÄ schema.go        # üÜï An√°lise de schema
```

## üöÄ Plano de Implementa√ß√£o

### **Fase 1: Limpeza e Padroniza√ß√£o**

#### 1.1 Definir Entidade Canonical
- ‚úÖ Usar [`internal/domain/entity/session.go`](internal/domain/entity/session.go) como base
- ‚ùå Remover [`internal/domain/entities.go`](internal/domain/entities.go) 
- üîß Atualizar todos os imports e refer√™ncias

#### 1.2 Normalizar SessionModel
- üîß Atualizar [`internal/infra/models/session.go`](internal/infra/models/session.go) para refletir exatamente a entidade
- üîß Implementar convers√µes precisas `ToDomain()` e `FromDomain()`
- ‚úÖ Manter todas as tags Bun necess√°rias no model

### **Fase 2: Sistema de Migrations Autom√°ticas**

#### 2.1 Detector de Mudan√ßas
```go
// internal/infra/database/migrator/differ.go
type SchemaDiffer struct {
    db *bun.DB
}

func (d *SchemaDiffer) DetectChanges(models []interface{}) (*MigrationDiff, error) {
    currentSchema := d.getCurrentSchema()
    expectedSchema := d.generateSchemaFromModels(models)
    return d.compareSchemas(currentSchema, expectedSchema)
}
```

#### 2.2 Gerador de Migrations
```go
// internal/infra/database/migrator/generator.go
type MigrationGenerator struct {
    diff *MigrationDiff
}

func (g *MigrationGenerator) GenerateMigration(name string) (*Migration, error) {
    timestamp := time.Now().Format("20060102150405")
    filename := fmt.Sprintf("%s_%s.go", timestamp, name)
    
    upSQL := g.generateUpSQL()
    downSQL := g.generateDownSQL()
    
    return &Migration{
        Name:     filename,
        UpSQL:    upSQL,
        DownSQL:  downSQL,
    }, nil
}
```

#### 2.3 Comandos CLI Autom√°ticos
```bash
# Gerar migration baseada em mudan√ßas dos models
go run cmd/migrate/main.go db generate --name="add_user_table"

# Detectar diferen√ßas sem gerar migration
go run cmd/migrate/main.go db diff

# Aplicar migrations pendentes
go run cmd/migrate/main.go db migrate

# Status detalhado
go run cmd/migrate/main.go db status
```

### **Fase 3: Migra√ß√£o das Migrations Existentes**

#### 3.1 Converter Migration Manual
- üîß Analisar [`20250109000001_create_sessions.go`](internal/infra/database/migrations/20250109000001_create_sessions.go)
- üÜï Gerar migration autom√°tica equivalente baseada no model atualizado
- ‚úÖ Manter compatibilidade com dados existentes

#### 3.2 Validar Integridade
```go
// Comando para validar sincroniza√ß√£o
func ValidateSchemaSync(db *bun.DB, models []interface{}) error {
    differ := NewSchemaDiffer(db)
    diff, err := differ.DetectChanges(models)
    if err != nil {
        return err
    }
    
    if !diff.IsEmpty() {
        return fmt.Errorf("schema out of sync: %+v", diff)
    }
    
    return nil
}
```

### **Fase 4: Sistema de Versionamento**

#### 4.1 Controle de Vers√£o Autom√°tico
```go
type MigrationVersion struct {
    Timestamp time.Time
    Hash      string      // Hash dos models
    Models    []string    // Lista de models inclu√≠dos
    Changes   []Change    // Mudan√ßas espec√≠ficas
}
```

#### 4.2 Rollback Inteligente
- üîß Gerar automaticamente comandos DOWN baseados nas mudan√ßas
- ‚úÖ Validar seguran√ßa do rollback
- ‚ö†Ô∏è Alertar sobre poss√≠vel perda de dados

## üîß Implementa√ß√£o T√©cnica Detalhada

### **Estrutura do Modelo Bun com Conven√ß√£o de Nomenclatura**

```go
// internal/infra/models/session.go
type SessionModel struct {
    bun.BaseModel `bun:"table:sessions"`

    // Campos principais (seguindo entity/session.go)
    // üìù Conven√ß√£o: camelCase em Go -> snake_case autom√°tico no PostgreSQL
    ID     string `bun:"id,pk" json:"id"`
    Name   string `bun:"name,unique,notnull" json:"name"`
    Status string `bun:"status,notnull,default:'disconnected'" json:"status"`
    Phone  string `bun:"phone" json:"phone"`

    // Campos WhatsApp
    // DeviceJID (Go) -> device_jid (PostgreSQL) - convers√£o autom√°tica via Bun
    DeviceJID  string `bun:"deviceJID,default:''" json:"deviceJID"`
    // WebhookURL (Go) -> webhook_url (PostgreSQL) - convers√£o autom√°tica via Bun
    WebhookURL string `bun:"webhookURL,default:''" json:"webhookURL"`
    Events     string `bun:"events,default:''" json:"events"`

    // Campos de proxy (desnormalizados para performance)
    // ProxyType (Go) -> proxy_type (PostgreSQL) - convers√£o autom√°tica via Bun
    ProxyType     *string `bun:"proxyType" json:"proxyType"`
    ProxyHost     *string `bun:"proxyHost" json:"proxyHost"`
    ProxyPort     *int    `bun:"proxyPort" json:"proxyPort"`
    ProxyUsername *string `bun:"proxyUsername" json:"proxyUsername"`
    ProxyPassword *string `bun:"proxyPassword" json:"proxyPassword"`

    // Auditoria
    // CreatedAt (Go) -> created_at (PostgreSQL) - convers√£o autom√°tica via Bun
    CreatedAt time.Time `bun:"createdAt,nullzero,notnull,default:current_timestamp" json:"createdAt"`
    UpdatedAt time.Time `bun:"updatedAt,nullzero,notnull,default:current_timestamp" json:"updatedAt"`
}
```

**üéØ Conven√ß√£o de Nomenclatura Adotada:**
- **Go structs**: `camelCase` (DeviceJID, WebhookURL, CreatedAt, ProxyType)
- **PostgreSQL**: `snake_case` (device_jid, webhook_url, created_at, proxy_type)
- **Convers√£o**: Autom√°tica via `bun.NamingStrategy` e tags Bun
- **Benef√≠cios**:
  - ‚úÖ C√≥digo Go idiom√°tico (camelCase)
  - ‚úÖ SQL padr√£o PostgreSQL (snake_case)
  - ‚úÖ Convers√£o transparente e autom√°tica
  - ‚úÖ Zero configura√ß√£o adicional necess√°ria

### **Sistema de Gera√ß√£o de Migrations**

```go
// internal/infra/database/migrator/schema.go
type TableSchema struct {
    Name        string
    Columns     []ColumnSchema
    Indexes     []IndexSchema
    Constraints []ConstraintSchema
}

type ColumnSchema struct {
    Name         string
    Type         string
    Nullable     bool
    Default      *string
    IsPrimaryKey bool
    IsUnique     bool
}

func (g *MigrationGenerator) GenerateCreateTable(table TableSchema) string {
    var sql strings.Builder
    sql.WriteString(fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (\n", table.Name))
    
    for i, col := range table.Columns {
        sql.WriteString(fmt.Sprintf("    %s %s", col.Name, col.Type))
        
        if !col.Nullable {
            sql.WriteString(" NOT NULL")
        }
        
        if col.Default != nil {
            sql.WriteString(fmt.Sprintf(" DEFAULT %s", *col.Default))
        }
        
        if i < len(table.Columns)-1 {
            sql.WriteString(",")
        }
        sql.WriteString("\n")
    }
    
    // Adicionar constraints
    for _, constraint := range table.Constraints {
        sql.WriteString(fmt.Sprintf("    CONSTRAINT %s %s,\n", constraint.Name, constraint.Definition))
    }
    
    sql.WriteString(");")
    return sql.String()
}
```

## üîß Configura√ß√£o de Nomenclatura no Bun ORM

### **Configura√ß√£o Autom√°tica da Convers√£o**
```go
// internal/infra/database/bun.go
func NewBunConnection(cfg Config) (*BunConnection, error) {
    // ... c√≥digo existente ...
    
    // Criar inst√¢ncia Bun com naming strategy autom√°tica
    db := bun.NewDB(sqldb, pgdialect.New(), bun.WithDiscardUnknownColumns())
    
    // üéØ Configurar convers√£o autom√°tica camelCase -> snake_case
    // Esta configura√ß√£o garante que todos os fields em camelCase sejam
    // automaticamente convertidos para snake_case no PostgreSQL
    db.RegisterModel((*models.SessionModel)(nil))
    
    // ... resto do c√≥digo ...
}
```

### **Vantagens da Abordagem**
- ‚úÖ **C√≥digo Idiom√°tico**: Go usa camelCase naturalmente
- ‚úÖ **SQL Padr√£o**: PostgreSQL usa snake_case como conven√ß√£o
- ‚úÖ **Zero Config**: Bun faz convers√£o automaticamente
- ‚úÖ **Manutenibilidade**: Mudan√ßas de nome refletem automaticamente no banco
- ‚úÖ **Consist√™ncia**: Um padr√£o √∫nico para todo o projeto

## üîÑ Fluxo de Desenvolvimento Futuro

### **1. Desenvolvedor Altera Model**
```go
// Developer adiciona novo campo no SessionModel
type SessionModel struct {
    // ... campos existentes
    // üéØ Usando camelCase em Go (convers√£o autom√°tica para snake_case no PostgreSQL)
    LastActivity *time.Time `bun:"lastActivity" json:"lastActivity"` // üÜï NOVO CAMPO
}
```

### **2. Sistema Detecta Mudan√ßa Automaticamente**
```bash
$ make db-diff
üîç Detectando mudan√ßas no schema...
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ MUDAN√áAS DETECTADAS                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Tabela: sessions                        ‚îÇ
‚îÇ + Adicionar coluna: last_activity       ‚îÇ
‚îÇ   Tipo: TIMESTAMP WITH TIME ZONE NULL  ‚îÇ
‚îÇ   Origin: lastActivity (Go field)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **3. Gerar Migration Automaticamente**
```bash
$ make db-generate name="add_session_last_activity"
üöÄ Gerando migration...
‚úÖ Migration criada: 20250810230000_add_session_last_activity.go
üìù Convers√£o autom√°tica: lastActivity -> last_activity
```

### **4. Migration Gerada Automaticamente**
```go
// internal/infra/database/migrations/auto/20250810230000_add_session_last_activity.go
func init() {
    Migrations.MustRegister(func(ctx context.Context, db *bun.DB) error {
        fmt.Print(" [UP] adding column last_activity to sessions...")
        
        // üìù Note: lastActivity (Go) -> last_activity (PostgreSQL)
        _, err := db.ExecContext(ctx, `
            ALTER TABLE sessions
            ADD COLUMN last_activity TIMESTAMP WITH TIME ZONE NULL;
        `)
        
        return err
    }, func(ctx context.Context, db *bun.DB) error {
        fmt.Print(" [DOWN] removing column last_activity from sessions...")
        
        _, err := db.ExecContext(ctx, `
            ALTER TABLE sessions
            DROP COLUMN IF EXISTS last_activity;
        `)
        
        return err
    })
}
```

### **5. Aplicar Migration**
```bash
$ make db-migrate
üóÑÔ∏è Aplicando migrations...
‚úÖ Migration 20250810230000_add_session_last_activity aplicada
```

## üìä Benef√≠cios da Nova Arquitetura

### **üîí Seguran√ßa**
- ‚úÖ Imposs√≠vel desincroniza√ß√£o entre c√≥digo e banco
- ‚úÖ Rollbacks autom√°ticos e seguros
- ‚úÖ Valida√ß√£o de integridade cont√≠nua

### **üöÄ Produtividade**  
- ‚úÖ Zero migrations manuais
- ‚úÖ Detec√ß√£o autom√°tica de mudan√ßas
- ‚úÖ Fluxo de desenvolvimento simplificado

### **üîß Manutenibilidade**
- ‚úÖ Single source of truth (models)
- ‚úÖ Hist√≥rico completo de mudan√ßas
- ‚úÖ Clean Architecture preservada

### **üìà Escalabilidade**
- ‚úÖ Suporte para m√∫ltiples models
- ‚úÖ Migrations complexas autom√°ticas
- ‚úÖ Ambiente de desenvolvimento alinhado com produ√ß√£o

## ‚ö†Ô∏è Considera√ß√µes e Riscos

### **Riscos Identificados**
1. **Dados Existentes**: Precisa migrar dados da estrutura atual
2. **Downtime**: Algumas migrations podem exigir parada tempor√°ria
3. **Rollback Complexo**: Mudan√ßas estruturais podem ser irrevers√≠veis

### **Mitiga√ß√µes**
1. **Backup Autom√°tico**: Sempre antes de aplicar migrations
2. **Dry Run**: Testar migrations em ambiente de desenvolvimento
3. **Rollback Testing**: Validar todas as opera√ß√µes de rollback

## üéØ Crit√©rios de Sucesso

- [ ] ‚úÖ Zero migrations SQL manuais
- [ ] ‚úÖ 100% sincroniza√ß√£o entre models e banco
- [ ] ‚úÖ Fluxo de desenvolvimento < 30 segundos para mudan√ßas simples
- [ ] ‚úÖ Zero regress√µes na aplica√ß√£o existente
- [ ] ‚úÖ Cobertura de testes > 90% para o sistema de migrations
- [ ] ‚úÖ Documenta√ß√£o completa para desenvolvedores

---

**Pr√≥ximos Passos**: Iniciar implementa√ß√£o seguindo o plano detalhado acima, come√ßando pela limpeza das inconsist√™ncias e padroniza√ß√£o das entidades.